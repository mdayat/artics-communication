// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package repository

import (
	"context"
)

// iteratorForBulkInsertMeetingRoom implements pgx.CopyFromSource.
type iteratorForBulkInsertMeetingRoom struct {
	rows                 []BulkInsertMeetingRoomParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkInsertMeetingRoom) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkInsertMeetingRoom) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Name,
	}, nil
}

func (r iteratorForBulkInsertMeetingRoom) Err() error {
	return nil
}

func (q *Queries) BulkInsertMeetingRoom(ctx context.Context, arg []BulkInsertMeetingRoomParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"meeting_room"}, []string{"id", "name"}, &iteratorForBulkInsertMeetingRoom{rows: arg})
}

// iteratorForBulkInsertReservation implements pgx.CopyFromSource.
type iteratorForBulkInsertReservation struct {
	rows                 []BulkInsertReservationParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkInsertReservation) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkInsertReservation) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].UserID,
		r.rows[0].MeetingRoomID,
		r.rows[0].TimeSlotID,
		r.rows[0].Canceled,
		r.rows[0].CanceledAt,
	}, nil
}

func (r iteratorForBulkInsertReservation) Err() error {
	return nil
}

func (q *Queries) BulkInsertReservation(ctx context.Context, arg []BulkInsertReservationParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"reservation"}, []string{"id", "user_id", "meeting_room_id", "time_slot_id", "canceled", "canceled_at"}, &iteratorForBulkInsertReservation{rows: arg})
}

// iteratorForBulkInsertTimeSlot implements pgx.CopyFromSource.
type iteratorForBulkInsertTimeSlot struct {
	rows                 []BulkInsertTimeSlotParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkInsertTimeSlot) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkInsertTimeSlot) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].MeetingRoomID,
		r.rows[0].StartDate,
		r.rows[0].EndDate,
	}, nil
}

func (r iteratorForBulkInsertTimeSlot) Err() error {
	return nil
}

func (q *Queries) BulkInsertTimeSlot(ctx context.Context, arg []BulkInsertTimeSlotParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"time_slot"}, []string{"id", "meeting_room_id", "start_date", "end_date"}, &iteratorForBulkInsertTimeSlot{rows: arg})
}

// iteratorForBulkInsertUser implements pgx.CopyFromSource.
type iteratorForBulkInsertUser struct {
	rows                 []BulkInsertUserParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkInsertUser) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkInsertUser) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Email,
		r.rows[0].Password,
		r.rows[0].Name,
		r.rows[0].Role,
	}, nil
}

func (r iteratorForBulkInsertUser) Err() error {
	return nil
}

func (q *Queries) BulkInsertUser(ctx context.Context, arg []BulkInsertUserParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"user"}, []string{"id", "email", "password", "name", "role"}, &iteratorForBulkInsertUser{rows: arg})
}
